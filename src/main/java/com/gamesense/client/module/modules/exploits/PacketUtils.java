package com.gamesense.client.module.modules.exploits;

import com.gamesense.api.event.events.BlockResetEvent;
import com.gamesense.api.event.events.PacketEvent;
import com.gamesense.api.event.events.PlayerJumpEvent;
import com.gamesense.api.setting.values.BooleanSetting;
import com.gamesense.api.setting.values.IntegerSetting;
import com.gamesense.api.util.misc.Timer;
import com.gamesense.api.util.player.PlayerUtil;
import com.gamesense.client.module.Category;
import com.gamesense.client.module.Module;
import com.gamesense.client.module.ModuleManager;
import com.gamesense.client.module.modules.movement.Speed;
import me.zero.alpine.listener.EventHandler;
import me.zero.alpine.listener.Listener;
import net.minecraft.block.BlockContainer;
import net.minecraft.init.Items;
import net.minecraft.network.play.client.*;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraftforge.fml.common.network.internal.FMLProxyPacket;

import static com.gamesense.api.util.player.PlayerUtil.nullCheck;

@Module.Declaration(name = "PacketUtils",category = Category.Exploits)
public class PacketUtils extends Module {

    private boolean shouldStop = false;

    BooleanSetting breakReset = registerBoolean("No Break Reset", false);

    BooleanSetting antiGap = registerBoolean("Anti Gap Fail", false);

    BooleanSetting noRotate = registerBoolean("No Rotate", false);

    BooleanSetting noInteract = registerBoolean("No Interact", false);
    BooleanSetting containerOnly = registerBoolean("Container Only", false, () -> noInteract.getValue());
    BooleanSetting onlyGapple = registerBoolean("Only Gapple", false      , () -> noInteract.getValue());

    BooleanSetting packetJump = registerBoolean("Packet Jump", false);
    IntegerSetting delay = registerInteger("Min Jump Delay", 0,0,50, () -> packetJump.getValue());

    public  BooleanSetting packetUse = registerBoolean("Packet Use", false);
    public BooleanSetting food = registerBoolean("Food", true, () -> packetUse.getValue());
    public BooleanSetting potion = registerBoolean("Potion", true, () -> packetUse.getValue());
    public BooleanSetting all = registerBoolean("All", false, () -> packetUse.getValue());



    Timer timer = new Timer();

    @EventHandler
    private final Listener<PlayerJumpEvent> jumpEventListener = new Listener<>(event -> {

        if (packetJump.getValue())
            if ((delay.getValue() == 0 || timer.hasReached(delay.getValue(), true) && mc.player.onGround) && !ModuleManager.getModule(Speed.class).isEnabled()) {
                PlayerUtil.fakeJump();
                mc.player.setPosition(mc.player.posX, mc.player.posY + 1.1661092609382, mc.player.posZ);
                mc.player.motionY =  -0.0830778178;
                event.cancel();
            }

    });

    @EventHandler
    private final Listener<PacketEvent.Send> sendListener = new Listener<>(event -> {

        if (!nullCheck())
            return;

        if (event.getPacket() instanceof CPacketPlayerTryUseItemOnBlock && !mc.player.isSneaking() && noInteract.getValue()) {

            CPacketPlayerTryUseItemOnBlock packet = ((CPacketPlayerTryUseItemOnBlock) event.getPacket());

            if (containerOnly.getValue() && !(mc.world.getBlockState(packet.getPos()).getBlock() instanceof BlockContainer) ||
                    (onlyGapple.getValue() && mc.player.getHeldItemMainhand().getItem() != Items.GOLDEN_APPLE))
                return;

            mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, CPacketEntityAction.Action.START_SNEAKING));
            shouldStop = true;
        }
    });

    @EventHandler
    private final Listener<BlockResetEvent> blockResetEventListener = new Listener<>(event -> {

        if (!nullCheck())
            return;

        if (breakReset.getValue())
            event.cancel();

    });

    @SuppressWarnings("unused")
    @EventHandler
    private final Listener<PacketEvent.PostSend> postSendListener = new Listener<>(event -> {

        if (!nullCheck())
            return;

        if (event.getPacket() instanceof CPacketPlayerTryUseItemOnBlock && shouldStop && noInteract.getValue()) {

            CPacketPlayerTryUseItemOnBlock packet = ((CPacketPlayerTryUseItemOnBlock) event.getPacket());

            if (containerOnly.getValue() && !(mc.world.getBlockState(packet.getPos()).getBlock() instanceof BlockContainer))
                return;

            mc.player.connection.sendPacket(new CPacketEntityAction(mc.player, CPacketEntityAction.Action.STOP_SNEAKING));
            shouldStop = false;
        }
    });

    @EventHandler
    private final Listener<PacketEvent.Receive> receiveListener = new Listener<>(event -> {

        if (!nullCheck())
            return;

        if (event.getPacket() instanceof SPacketPlayerPosLook && noRotate.getValue()) {

            SPacketPlayerPosLook e = (SPacketPlayerPosLook) event.getPacket();

            e.pitch = mc.player.rotationPitch;
            e.yaw = mc.player.rotationYaw;


        }

    });

    @Override
    public void onUpdate() {

        if (!nullCheck())
            return;

        if (mc.player.canEat(true) && mc.player.isSwingInProgress && mc.player.getHeldItemMainhand().getItem().equals(Items.GOLDEN_APPLE) && antiGap.getValue()) {

            mc.player.connection.sendPacket(new CPacketHeldItemChange(mc.player.inventory.currentItem));

        }
    }

}
