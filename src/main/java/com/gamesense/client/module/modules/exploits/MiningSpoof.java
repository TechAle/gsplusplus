package com.gamesense.client.module.modules.exploits;

import com.gamesense.api.event.events.DamageBlockEvent;
import com.gamesense.api.event.events.PacketEvent;
import com.gamesense.api.event.events.PlayerMoveEvent;
import com.gamesense.api.setting.values.BooleanSetting;
import com.gamesense.api.util.misc.MessageBus;
import com.gamesense.api.util.player.InventoryUtil;
import com.gamesense.api.util.player.RotationUtil;
import com.gamesense.client.module.Category;
import com.gamesense.client.module.Module;
import me.zero.alpine.listener.EventHandler;
import me.zero.alpine.listener.Listener;
import net.minecraft.block.Block;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.item.Item;
import net.minecraft.item.ItemAxe;
import net.minecraft.item.ItemSword;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec2f;
import net.minecraft.util.math.Vec3d;

@Module.Declaration(name = "MiningSpoof", category = Category.Exploits)
public class MiningSpoof extends Module {

    boolean noPick;

    BooleanSetting ignoreAxe = registerBoolean("IgnoreAxe", false);
    BooleanSetting ignoreSword = registerBoolean("IgnoreSword", false);
    BooleanSetting credits = registerBoolean("Credits", false);

    @Override
    protected void onEnable() {
        if (credits.getValue())
            MessageBus.sendClientPrefixMessageWithID("SRC from CookieClient at https://github.com/bebeli555/CookieClient/blob/main/src/main/java/me/bebeli555/cookieclient/mods/exploits/MiningSpoof.java",
                    getIdFromString("SRC from CookieClient at https://github.com/bebeli555/CookieClient/blob/main/src/main/java/me/bebeli555/cookieclient/mods/exploits/MiningSpoof.java"));
    }

    @Override
    protected void onDisable() {
        noPick = false;
    }

    @EventHandler
    private final Listener<PlayerMoveEvent> eventListener = new Listener<>(event -> {
        if (mc.player == null || !mc.gameSettings.keyBindAttack.isKeyDown()) {
            return;
        }

        assert !mc.world.isOutsideBuildHeight(mc.objectMouseOver.getBlockPos());

        if (mc.world.getBlockState(mc.objectMouseOver.getBlockPos()).getBlockHardness(mc.world, mc.objectMouseOver.getBlockPos()) <= 0) {
            noPick = true;
            return;
        }

        if (!shouldMineSpoof()) {
            return;
        }

        int pickSlot = getPickaxeSlot();
        if (pickSlot == -1) {
            noPick = true;
            return;
        } else if (pickSlot == mc.player.inventory.currentItem) {
            return;
        }

        noPick = false;
        int oldSlot = mc.player.inventory.currentItem;

        //Switch to pickaxe
        mc.player.inventory.currentItem = pickSlot;
        mc.playerController.updateController();

        //Mine block
        mc.player.swingArm(EnumHand.MAIN_HAND);
        mc.playerController.onPlayerDamageBlock(mc.objectMouseOver.getBlockPos(), mc.objectMouseOver.sideHit);

        //Switch to old slot
        mc.player.inventory.currentItem = oldSlot;
        mc.playerController.updateController();
    });

    @EventHandler
    private final Listener<DamageBlockEvent> playerDamageBlockEvent = new Listener<>(event -> {
        if (mc.player.inventory.currentItem != getPickaxeSlot() && !noPick && shouldMineSpoof()) {
            event.cancel();
        }
    });

    public boolean shouldMineSpoof() {
        //Check if player is holding an ignored item and then return
        Item held = mc.player.getHeldItemMainhand().getItem();
        if (ignoreAxe.getValue() && held instanceof ItemAxe || ignoreSword.getValue() && held instanceof ItemSword) {
            return false;
        }

        //Dont minespoof some blocks
        Block[] dontMine = {Blocks.WEB};
        for (Block block : dontMine) {
            if (block == mc.world.getBlockState(mc.objectMouseOver.getBlockPos()).getBlock()) {
                return false;
            }
        }

        return true;
    }

    public static int getPickaxeSlot() {
        Item[] picks = {Items.DIAMOND_PICKAXE, Items.GOLDEN_PICKAXE, Items.IRON_PICKAXE, Items.STONE_PICKAXE, Items.WOODEN_PICKAXE};

        for (Item pick : picks) {
            if (InventoryUtil.findFirstItemSlot(pick.getClass(), 0,8) != -1) {
                return InventoryUtil.findFirstItemSlot(pick.getClass(), 0,8);
            }
        }

        return -1;
    }

    public static class CancelForceRotation {
        public static CancelForceRotation instance = new CancelForceRotation();

        @EventHandler
        private final Listener<PacketEvent.Send> packetEvent = new Listener<>(event -> {
            if (mc.player == null) {
                return;
            }

            if (event.getPacket() instanceof SPacketPlayerPosLook) {
                event.cancel();

                SPacketPlayerPosLook packet = (SPacketPlayerPosLook)event.getPacket();
                mc.player.setPosition(packet.getX(), packet.getY(), packet.getZ());
                mc.player.motionY = 0;

                Vec2f rotations = RotationUtil.getRotationTo(new Vec3d(new BlockPos(mc.player.getPositionVector()).add(0, -1, 0)).add(0.5, 0.5, 0.5).add(new Vec3d(EnumFacing.UP.getDirectionVec()).scale(0.5)));

                mc.player.connection.sendPacket(new CPacketConfirmTeleport(packet.getTeleportId()));
                mc.player.connection.sendPacket(new CPacketPlayer.PositionRotation(mc.player.posX, mc.player.getEntityBoundingBox().minY, mc.player.posZ, rotations.x, rotations.y, false));
            }
        });
    }
}
